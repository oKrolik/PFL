╔═══════════════════════════════════════════════════════════════════════════════╗
║                       HASKELL & PROLOG CHEAT-SHEET                            ║
║                         Complete Reference Guide                              ║
╚═══════════════════════════════════════════════════════════════════════════════╝

═══════════════════════════════════════════════════════════════════════════════
                              HASKELL SECTION
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│ 1. CORE LIST OPERATIONS                                                     │
└─────────────────────────────────────────────────────────────────────────────┘

-- Basic operations
myConcat :: [[a]] -> [a]
myConcat = foldr (++) []

myReplicate :: Int -> a -> [a]
myReplicate n x | n > 0 = x : myReplicate (n-1) x
                | otherwise = []

(!!!) :: [a] -> Int -> a
(x:xs) !!! 0 = x
(x:xs) !!! n = xs !!! (n-1)

myElem :: Eq a => a -> [a] -> Bool
myElem _ [] = False
myElem y (x:xs) = (y == x) || myElem y xs

(+++) :: [a] -> [a] -> [a]
(+++) xs ys = foldr (:) ys xs

-- Remove duplicates
nub :: Eq a => [a] -> [a]
nub [] = []
nub (x:xs) = x : nub (filter (/= x) xs)

-- Intersperse element between list elements
intersperse :: a -> [a] -> [a]
intersperse _ [] = []
intersperse _ [x] = [x]
intersperse s (x:xs) = x : s : intersperse s xs

-- Reverse implementations
reversefl, reversefr :: [a] -> [a]
reversefl = foldl (flip (:)) []
reversefr = foldr (\x acc -> acc ++ [x]) []

┌─────────────────────────────────────────────────────────────────────────────┐
│ 2. FOLD PATTERNS                                                            │
└─────────────────────────────────────────────────────────────────────────────┘

sumList = foldr (+) 0
productList = foldr (*) 1
andList = foldr (&&) True
orList = foldr (||) False
concatList = foldr (++) []
lengthList = foldr (\_ acc -> acc + 1) 0
maximumList = foldr1 max
minimumList = foldr1 min

┌─────────────────────────────────────────────────────────────────────────────┐
│ 3. SORTING & SEARCHING                                                      │
└─────────────────────────────────────────────────────────────────────────────┘

-- Insertion sort
isort :: Ord a => [a] -> [a]
isort [] = []
isort (x:xs) = insert x (isort xs)

insert :: Ord a => a -> [a] -> [a]
insert x [] = [x]
insert x (y:ys) | x <= y = x : y : ys
                | otherwise = y : insert x ys

-- Merge two sorted lists
merge :: Ord a => [a] -> [a] -> (a -> a -> Bool) -> [a]
merge [] l _ = l
merge l [] _ = l
merge (x:xs) (y:ys) cmp
    | cmp x y = x : merge xs (y:ys) cmp
    | otherwise = y : merge (x:xs) ys cmp

-- Merge sort
sortByCond :: Ord a => [a] -> (a -> a -> Bool) -> [a]
sortByCond [] _ = []
sortByCond [x] _ = [x]
sortByCond l cmp = merge (sortByCond l1 cmp) (sortByCond l2 cmp) cmp
  where (l1, l2) = splitAt (length l `div` 2) l

┌─────────────────────────────────────────────────────────────────────────────┐
│ 4. HIGHER-ORDER FUNCTIONS                                                   │
└─────────────────────────────────────────────────────────────────────────────┘

-- Composition & application
(.) :: (b -> c) -> (a -> b) -> a -> c
(f . g) x = f (g x)

($) :: (a -> b) -> a -> b
f $ x = f x

-- Function application patterns
twice :: (a -> a) -> a -> a
twice f x = f (f x)

-- Map, filter, zipWith patterns
map f [] = []
map f (x:xs) = f x : map f xs

filter p [] = []
filter p (x:xs) | p x = x : filter p xs
                | otherwise = filter p xs

zipWith f [] _ = []
zipWith f _ [] = []
zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys

┌─────────────────────────────────────────────────────────────────────────────┐
│ 5. TREES & RECURSIVE DATA STRUCTURES                                        │
└─────────────────────────────────────────────────────────────────────────────┘

data Arv a = F | N a (Arv a) (Arv a) deriving Show
data Set a = Empty | Node a (Set a) (Set a)

-- BST Insert
insert :: Ord a => a -> Set a -> Set a
insert x Empty = Node x Empty Empty
insert x (Node y left right)
    | x < y = Node y (insert x left) right
    | x > y = Node y left (insert x right)
    | otherwise = Node y left right

-- BST Member
member :: Ord a => a -> Set a -> Bool
member _ Empty = False
member x (Node y left right)
    | x == y = True
    | x < y = member x left
    | otherwise = member x right

-- Tree height
altura :: Arv a -> Int
altura F = 0
altura (N _ l r) = 1 + max (altura l) (altura r)

-- Tree map
treeMap :: (a -> b) -> Set a -> Set b
treeMap _ Empty = Empty
treeMap f (Node v l r) = Node (f v) (treeMap f l) (treeMap f r)

-- Build balanced BST from sorted list
fromList :: Ord a => [a] -> Set a
fromList xs = build (sort xs)
  where build [] = Empty
        build xs = Node x (build xs') (build xs'')
          where k = length xs `div` 2
                xs' = take k xs
                (x:xs'') = drop k xs

┌─────────────────────────────────────────────────────────────────────────────┐
│ 6. MATRICES & LINEAR ALGEBRA                                                │
└─────────────────────────────────────────────────────────────────────────────┘

type Vector = [Int]
type Matriz = [[Int]]

transposta :: Matriz -> Matriz
transposta [] = []
transposta m = [head x | x <- m] : transposta [tail x | x <- m, tail x /= []]

prodInterno :: Vector -> Vector -> Int
prodInterno [] [] = 0
prodInterno (x:xs) (y:ys) = x * y + prodInterno xs ys

prodMat :: Matriz -> Matriz -> Matriz
prodMat m1 m2 = [[prodInterno v1 v2 | v2 <- transposta m2] | v1 <- m1]

┌─────────────────────────────────────────────────────────────────────────────┐
│ 7. COMBINATORICS & MATH                                                     │
└─────────────────────────────────────────────────────────────────────────────┘

fact :: Integer -> Integer
fact n = product [1..n]

binom :: Integer -> Integer -> Integer
binom n k = fact n `div` (fact k * fact (n-k))

pascal :: Integer -> [[Integer]]
pascal x = [[binom n k | k <- [0..n]] | n <- [0..x]]

propDivs :: Integer -> [Integer]
propDivs n = [x | x <- [1..n-1], n `mod` x == 0]

perfects :: Integer -> [Integer]
perfects n = [x | x <- [1..n], sum (propDivs x) == x]

pyths :: Integer -> [(Integer,Integer,Integer)]
pyths n = [(x,y,z) | x <- [1..n], y <- [1..n], z <- [1..n], x^2 + y^2 == z^2]

┌─────────────────────────────────────────────────────────────────────────────┐
│ 8. INFINITE LISTS & LAZY EVALUATION                                         │
└─────────────────────────────────────────────────────────────────────────────┘

-- Fibonacci
fibs :: [Integer]
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)

-- Primes (basic sieve)
primes :: [Integer]
primes = sieve [2..]
  where sieve (p:xs) = p : sieve [x | x <- xs, x `mod` p /= 0]

-- Twin primes
twinPrimes :: [(Integer,Integer)]
twinPrimes = filter (\(x,y) -> y == x+2) (zip primes (tail primes))

-- Recursive series: a_n = 3*a_(n-1) - 2*a_(n-2)
series :: [Integer]
series = 0 : 1 : zipWith (\a1 a2 -> 3*a1 - 2*a2) (tail series) series

-- Pi approximations
calcPi1, calcPi2 :: Int -> Double
calcPi1 n = sum (take n (zipWith (/) (cycle [4,-4]) [1,3..]))
calcPi2 n = 3.0 + sum (take n (zipWith (/) (cycle [4,-4]) [k*(k+1)*(k+2) | k <- [2,4..]]))

┌─────────────────────────────────────────────────────────────────────────────┐
│ 9. STRING & CHAR OPERATIONS                                                 │
└─────────────────────────────────────────────────────────────────────────────┘

-- Password strength
forte :: String -> Bool
forte str = length str >= 8
    && any (`elem` ['A'..'Z']) str
    && any (`elem` ['a'..'z']) str
    && any (`elem` ['0'..'9']) str

-- Vowel transformation (e.g., "a" -> "apa")
transforma :: String -> String
transforma [] = []
transforma (x:xs)
    | x `elem` "aeiou" = x : 'p' : x : transforma xs
    | otherwise = x : transforma xs

┌─────────────────────────────────────────────────────────────────────────────┐
│ 10. TYPE CLASSES & TYPE INFERENCE                                           │
└─────────────────────────────────────────────────────────────────────────────┘

-- Common type signatures
second :: [a] -> a
swap :: (a, b) -> (b, a)
pair :: a -> (a, a)
double :: Num a => a -> a
half :: Fractional a => a -> a
average :: Fractional a => a -> a -> a
isLower :: Char -> Bool
inRange :: Ord a => a -> a -> a -> Bool
isPalindrome :: Eq a => [a] -> Bool
twice :: (a -> a) -> a -> a

-- Type class hierarchy
-- Eq -> Ord -> Num -> Integral
--                 \-> Fractional -> Floating

-- "type" vs "data":
-- - Only "data" allows recursive definitions
-- - Only "data" defines new patterns for pattern matching
-- - "data" can derive typeclasses like Eq, Show, etc.

┌─────────────────────────────────────────────────────────────────────────────┐
│ 11. MONADS & IO                                                             │
└─────────────────────────────────────────────────────────────────────────────┘

-- Maybe, State, IO are all monads
-- IO type signature example:
-- putStrLn :: String -> IO ()
-- getLine :: IO String

-- Do notation pattern:
readAndProcess :: IO ()
readAndProcess = do
    x <- getLine
    if x == "quit"
        then return ()
        else do
            putStrLn ("You said: " ++ x)
            readAndProcess

┌─────────────────────────────────────────────────────────────────────────────┐
│ 12. GRAPH ALGORITHMS                                                        │
└─────────────────────────────────────────────────────────────────────────────┘

type City = String
type Distance = Int
type RoadMap = [(City, City, Distance)]

-- Get adjacent cities
adjacent :: RoadMap -> City -> [(City, Distance)]
adjacent roadMap city = 
    [(dest, dist) | (orig, dest, dist) <- roadMap, orig == city] ++
    [(orig, dist) | (orig, dest, dist) <- roadMap, dest == city]

-- DFS connectivity check
areConnected :: RoadMap -> City -> City -> Bool
areConnected roadMap start end = end `elem` dfs roadMap [] [start]
  where
    dfs _ visited [] = visited
    dfs roadMap visited (top:stack)
        | top `elem` visited = dfs roadMap visited stack
        | otherwise = dfs roadMap (top:visited) (adjs ++ stack)
        where adjs = map fst $ adjacent roadMap top

-- Path distance
pathDistance :: [(City,City,Distance)] -> [City] -> Maybe Distance
pathDistance edges [] = Just 0
pathDistance edges (start:path) = aux start 0 path
  where
    aux v acc [] = Just acc
    aux v acc (u:path) =
        case [d | (x,y,d) <- edges, x == v, y == u] of
            (d:_) -> aux u (acc+d) path
            [] -> Nothing

┌─────────────────────────────────────────────────────────────────────────────┐
│ 13. PROPOSITIONAL LOGIC                                                     │
└─────────────────────────────────────────────────────────────────────────────┘

type VarName = Char

data Prop = Const Bool
          | Variable VarName
          | Not Prop
          | And Prop Prop
          | Imply Prop Prop
          deriving Show

valor :: Prop -> Bool
valor (Const b) = b
valor (Variable _) = False
valor (Not p) = not (valor p)
valor (And p q) = valor p && valor q
valor (Imply p q) = not (valor p) || valor q

rename :: [(VarName,VarName)] -> Prop -> Prop
rename _ (Const b) = Const b
rename ren (Variable x) = case lookup x ren of
                             Just y -> Variable y
                             Nothing -> Variable x
rename ren (Not p) = Not (rename ren p)
rename ren (And p q) = And (rename ren p) (rename ren q)
rename ren (Imply p q) = Imply (rename ren p) (rename ren q)

vars :: Prop -> [VarName]
vars (Const _) = []
vars (Variable x) = [x]
vars (Not p) = vars p
vars (And p q) = vars p ++ vars q
vars (Imply p q) = vars p ++ vars q

normalize :: Prop -> Prop
normalize p = rename (zip uniqueVars ['a'..]) p
  where uniqueVars = nub (vars p)


═══════════════════════════════════════════════════════════════════════════════
                              PROLOG SECTION
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│ 1. BASIC RECURSION PATTERNS                                                 │
└─────────────────────────────────────────────────────────────────────────────┘

% Factorial
factorial(0, 1).
factorial(N, F) :- N > 0, N1 is N - 1, factorial(N1, F1), F is N * F1.

% Tail-recursive factorial
factorial_tr(N, F) :- factorial_acc(N, 1, F).
factorial_acc(0, Acc, Acc).
factorial_acc(N, Acc, F) :- 
    N > 0, Acc1 is Acc * N, N1 is N - 1, factorial_acc(N1, Acc1, F).

% Fibonacci
fib(0, 0).
fib(1, 1).
fib(N, F) :- 
    N > 1, N1 is N - 1, N2 is N - 2, 
    fib(N1, F1), fib(N2, F2), F is F1 + F2.

% Power
pow(_, 0, 1).
pow(X, 1, X).
pow(X, Y, P) :- Y > 1, Y1 is Y - 1, pow(X, Y1, P1), P is X * P1.

% Sum from 1 to N
sum_rec(0, 0).
sum_rec(N, S) :- N > 0, N1 is N - 1, sum_rec(N1, S1), S is N + S1.

┌─────────────────────────────────────────────────────────────────────────────┐
│ 2. LIST OPERATIONS                                                          │
└─────────────────────────────────────────────────────────────────────────────┘

% List size
list_size([], 0).
list_size([_|T], Size) :- list_size(T, SizeT), Size is SizeT + 1.

% List sum
list_sum([], 0).
list_sum([H|T], Sum) :- list_sum(T, SumT), Sum is SumT + H.

% List product
list_prod([], 1).
list_prod([H|T], Prod) :- list_prod(T, ProdT), Prod is ProdT * H.

% Reverse
invert([], []).
invert([H|T], R) :- invert(T, RT), append(RT, [H], R).

% Better reverse (tail-recursive)
reverse_tr(L, R) :- reverse_acc(L, [], R).
reverse_acc([], Acc, Acc).
reverse_acc([H|T], Acc, R) :- reverse_acc(T, [H|Acc], R).

% Delete all occurrences
del_all(_, [], []).
del_all(X, [X|T], R) :- del_all(X, T, R).
del_all(X, [H|T], [H|R]) :- X \= H, del_all(X, T, R).

% Count occurrences
count(_, [], 0).
count(X, [X|T], N) :- count(X, T, N1), N is N1 + 1.
count(X, [H|T], N) :- X \= H, count(X, T, N).

% Remove duplicates
del_dups([], []).
del_dups([H|T], [H|R]) :- \+ member(H, T), del_dups(T, R).
del_dups([H|T], R) :- member(H, T), del_dups(T, R).

% Insert at position
insert_elem(1, List, Elem, [Elem|List]).
insert_elem(I, [X|Xs], Elem, [X|R]) :- 
    I > 1, I1 is I - 1, insert_elem(I1, Xs, Elem, R).

% Delete at position
delete_elem(1, [X|Xs], X, Xs).
delete_elem(I, [X|Xs], Elem, [X|R]) :- 
    I > 1, I1 is I - 1, delete_elem(I1, Xs, Elem, R).

% Replace at position
replace([Old|Xs], 1, Old, New, [New|Xs]).
replace([X|Xs], I, Old, New, [X|R]) :- 
    I > 1, I1 is I - 1, replace(Xs, I1, Old, New, R).

% Maximum element
max_list([X], X).
max_list([H|T], Max) :-
    max_list(T, M1),
    (H >= M1 -> Max = H ; Max = M1).

┌─────────────────────────────────────────────────────────────────────────────┐
│ 3. APPEND-BASED PATTERNS                                                    │
└─────────────────────────────────────────────────────────────────────────────┘

% Append definition
list_append([], L, L).
list_append([H|T], L, [H|R]) :- list_append(T, L, R).

% Member using append
list_member(X, L) :- append(_, [X|_], L).

% Last element
list_last(L, X) :- append(_, [X], L).

% Nth element
list_nth(N, L, X) :- length(Prefix, N1), N is N1 + 1, append(Prefix, [X|_], L).

% Before predicate
before(F, S, L) :- append(_, [F|L2], L), append(_, [S|_], L2).

% Delete one occurrence
list_del(L, X, R) :- append(Front, [X|Back], L), append(Front, Back, R).

┌─────────────────────────────────────────────────────────────────────────────┐
│ 4. HIGHER-ORDER PREDICATES                                                  │
└─────────────────────────────────────────────────────────────────────────────┘

% Map (applies predicate to all elements)
map(_, [], []).
map(P, [H|T], [R|RT]) :-
    G =.. [P, H, R],
    call(G),
    map(P, T, RT).

% Filter
filter(_, [], []).
filter(P, [H|T], [H|R]) :-
    G =.. [P, H],
    call(G),
    filter(P, T, R).
filter(P, [_|T], R) :- filter(P, T, R).

% Fold (reduce)
fold(_, Acc, [], Acc).
fold(P, Acc0, [H|T], AccF) :-
    G =.. [P, Acc0, H, Acc1],
    call(G),
    fold(P, Acc1, T, AccF).

┌─────────────────────────────────────────────────────────────────────────────┐
│ 5. FINDALL, BAGOF, SETOF                                                    │
└─────────────────────────────────────────────────────────────────────────────┘

% findall(X, Goal, List) - always succeeds, returns [] if no solutions
% bagof(X, Goal, List) - fails if no solutions, may return multiple lists
% setof(X, Goal, List) - sorted & unique, fails if no solutions

% Common patterns:
% findall(X, Goal, L).                      % collect all solutions
% findall(A-B, Goal, L).                    % collect pairs
% findall(X, (G1, findall(Y, G2, Ys)), L).  % nested collection
% setof(X, Y^Goal, L).                      % existential quantification

% Example: Count dishes with ingredient
count_dishes_with_ingredient(Ingredient, N) :-
    findall(Dish, (dish(Dish, _, Ingredients), member(Ingredient-_, Ingredients)), Dishes),
    length(Dishes, N).

┌─────────────────────────────────────────────────────────────────────────────┐
│ 6. GRAPH SEARCH (DFS/BFS)                                                   │
└─────────────────────────────────────────────────────────────────────────────┘

% DFS (with cycle detection)
dfs(Goal, Goal, _, []).
dfs(Start, Goal, Visited, [Edge|Path]) :-
    edge(Start, Next, Edge),
    \+ member(Next, Visited),
    dfs(Next, Goal, [Next|Visited], Path).

% BFS (using queue)
bfs(Start, Goal, Path) :- bfs_queue([[Start]], Goal, Path).

bfs_queue([[Goal|Rest]|_], Goal, Path) :- reverse([Goal|Rest], Path).
bfs_queue([Path|Others], Goal, Final) :-
    Path = [Node|_],
    findall([Next|Path],
            (edge(Node, Next, _), \+ member(Next, Path)),
            Expansions),
    append(Others, Expansions, NewQueue),
    bfs_queue(NewQueue, Goal, Final).

% Connectivity check
connects(X, Y, Path) :- connects(X, [X], Y, Path).
connects(X, Path, X, RevPath) :- reverse(Path, RevPath).
connects(X, Visited, Y, Path) :-
    edge(X, Z, _),
    \+ member(Z, Visited),
    connects(Z, [Z|Visited], Y, Path).

┌─────────────────────────────────────────────────────────────────────────────┐
│ 7. DYNAMIC PREDICATES & ASSERT/RETRACT                                      │
└─────────────────────────────────────────────────────────────────────────────┘

% Memoized Fibonacci
:- dynamic fib_memo/2.

fib_memo(0, 0).
fib_memo(1, 1).
fib_memo(N, F) :-
    N > 1,
    N1 is N - 1,
    N2 is N - 2,
    fib_memo(N1, F1),
    fib_memo(N2, F2),
    F is F1 + F2,
    asserta(fib_memo(N, F)).

% Update ingredient cost
update_unit_cost(Ingredient, NewCost) :-
    retractall(ingredient(Ingredient, _)),
    asserta(ingredient(Ingredient, NewCost)).

┌─────────────────────────────────────────────────────────────────────────────┐
│ 8. TREES IN PROLOG                                                          │
└─────────────────────────────────────────────────────────────────────────────┘

% Tree structure: nil or t(Value, Left, Right)

% Size
tree_size(nil, 0).
tree_size(t(_, L, R), N) :- 
    tree_size(L, NL), tree_size(R, NR), N is NL + NR + 1.

% Height
tree_height(nil, 0).
tree_height(t(_, L, R), H) :-
    tree_height(L, HL), tree_height(R, HR),
    H is max(HL, HR) + 1.

% Leaves count
tree_leaves(nil, 0).
tree_leaves(t(_, nil, nil), 1).
tree_leaves(t(_, L, R), N) :-
    tree_leaves(L, NL), tree_leaves(R, NR),
    N is NL + NR.

% Tree map
tree_map(_, nil, nil).
tree_map(P, t(X, L, R), t(Y, NL, NR)) :-
    G =.. [P, X, Y], call(G),
    tree_map(P, L, NL), tree_map(P, R, NR).

┌─────────────────────────────────────────────────────────────────────────────┐
│ 9. META-PROGRAMMING                                                         │
└─────────────────────────────────────────────────────────────────────────────┘

% Univ operator (=..)
% Converts between term and list representation
% T =.. [Functor|Args]

% Examples:
% foo(a, b, c) =.. [foo, a, b, c]
% T =.. [+, 2, 3] gives T = 2 + 3

% Get functor and arity
my_functor(T, F, N) :- T =.. [F|Args], length(Args, N).

% Get nth argument
my_arg(I, T, A) :- T =.. [_|Args], nth1(I, Args, A).

% Test if second argument is uninstantiated
test_second_uninstantiated(T) :-
    T =.. [_, _, X|_],
    var(X).

┌─────────────────────────────────────────────────────────────────────────────┐
│ 10. CUT & NEGATION                                                          │
└─────────────────────────────────────────────────────────────────────────────┘

% Green cut (doesn't change semantics, only efficiency)
max(X, Y, X) :- X >= Y, !.
max(_, Y, Y).

% Red cut (changes semantics)
min_list([X], X) :- !.
min_list([H|T], M) :- min_list(T, M1), M is min(H, M1).

% Negation as failure
\+ Goal   % Goal fails

% Not member
not_member(_, []).
not_member(X, [H|T]) :- X \= H, not_member(X, T).

┌─────────────────────────────────────────────────────────────────────────────┐
│ 11. OPERATORS                                                               │
└─────────────────────────────────────────────────────────────────────────────┘

% Define custom operators:
% :- op(Precedence, Type, Name).

% Types:
%   xfx - infix, non-associative  (e.g., =, <)
%   yfx - infix, left-associative (e.g., +, -)
%   xfy - infix, right-associative (e.g., ^)
%   fx  - prefix  (e.g., -)
%   fy  - prefix  (e.g., \+)
%   xf  - postfix
%   yf  - postfix

% Example:
:- op(700, xfx, has).
:- op(600, xf, pages).
% Allows: 'The Firm' has 432 pages.

┌─────────────────────────────────────────────────────────────────────────────┐
│ 12. COMMON EXAM PATTERNS                                                    │
└─────────────────────────────────────────────────────────────────────────────┘

% Family relationships
parent(john, mary).
parent(john, tom).

siblings(X, Y) :- 
    parent(P, X), parent(P, Y), X \= Y.

grandparent(X, Y) :- 
    parent(X, Z), parent(Z, Y).

% Run-length encoding
rle([], []).
rle([H|T], [H-N|R]) :-
    count_run(H, T, N, Rest),
    rle(Rest, R).

count_run(X, [X|T], N, Rest) :-
    count_run(X, T, N1, Rest), N is N1 + 1.
count_run(X, [Y|T], 1, [Y|T]) :- X \= Y.
count_run(_, [], 1, []).

% Pascal's triangle
pascal(1, [[1]]).
pascal(N, Lines) :-
    N > 1, N1 is N - 1,
    pascal(N1, Prev),
    append(_, [LastLine], Prev),
    next_pascal_line(LastLine, New),
    append(Prev, [New], Lines).

next_pascal_line([X|Xs], [X|Ys]) :- next_aux(Xs, X, Ys).
next_aux([], Last, [Last]).
next_aux([X|Xs], Prev, [Sum|Ys]) :-
    Sum is Prev + X, next_aux(Xs, X, Ys).

% Unifiable elements
unifiable([], _, []).
unifiable([H|T], Term, [H|R]) :-
    \+ \+ (H = Term),  % Test unification without binding
    unifiable(T, Term, R).
unifiable([_|T], Term, R) :- unifiable(T, Term, R).

═══════════════════════════════════════════════════════════════════════════════
                           EXAM THEORY QUICK REFERENCE
═══════════════════════════════════════════════════════════════════════════════

HASKELL TYPE ERRORS:
✗ 1 + False          -- Can't add Int and Bool
✗ 'a' + 'b'          -- Can't add Chars
✗ 'a' ++ 'b'         -- ++ needs [Char], not Char
✗ 1+2 == "3"         -- Can't compare Int and String
✗ 'a' < "ab"         -- Can't compare Char and String
✗ (1 <= 2) <= 3      -- Can't compare Bool and Int
✗ head (1,2)         -- head needs list, not tuple

TYPE vs DATA:
- Only "data" allows recursive definitions
- Only "data" creates new pattern matching constructors
- Both allow type variables

EVALUATION ORDER:
- Lazy evaluation enables infinite data structures
- takeWhile (<1000) [1..] terminates
- length (filter (<1000) fibs) does NOT terminate (filter needs full evaluation)

FOLD DIRECTION:
- foldr (+) 7 [1,2,3] = 1 + (2 + (3 + 7)) = 13
- foldl (/) 200 [1,2,4] = ((200 / 1) / 2) / 4 = 25.0

TYPECLASSES:
- Every Ord instance is also an Eq instance
- (/) is in Fractional, not Integral
- Int is instance of Eq, Ord, Num

MONADS:
- Maybe, State, IO are all monads
- IO () means IO action returning unit

PROLOG FACTS:
- findall always succeeds (returns [] if none)
- bagof/setof fail if no solutions
- setof returns sorted, unique results
- Use Y^ to existentially quantify variables: setof(X, Y^goal(X,Y), L)

CUT COLORS:
- Green cut: doesn't change semantics (only efficiency)
- Red cut: changes semantics (removes choice points that affect correctness)

NEGATION:
- \+ Goal succeeds if Goal fails (negation as failure)
- Not the same as logical negation!

═══════════════════════════════════════════════════════════════════════════════
                              USEFUL PATTERNS
═══════════════════════════════════════════════════════════════════════════════

HASKELL COMMON IDIOMS:
- filter p . map f ≡ map f . filter (p . f) [when p doesn't depend on f]
- length . filter p ≡ length of elements satisfying p
- foldr (++) [] ≡ concat
- map f ≡ foldr ((:) . f) []
- filter p ≡ foldr (\x acc -> if p x then x:acc else acc) []

PROLOG COMMON IDIOMS:
- member(X, L) :- append(_, [X|_], L).
- last(L, X) :- append(_, [X], L).
- prefix(P, L) :- append(P, _, L).
- suffix(S, L) :- append(_, S, L).

═══════════════════════════════════════════════════════════════════════════════
                                    END
═══════════════════════════════════════════════════════════════════════════════
